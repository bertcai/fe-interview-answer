# 2023-2

## 2023-3-1

> [vue] 在 vue 中为什么使用 v-for 数据渲染顺序会混乱？如何解决？

Vue 中，使用 v-for 指令进行数据渲染时，可能会出现顺序混乱的情况，这通常是由于 Vue 的异步更新机制导致的, 具体来说，当数据发生变化时，Vue 不会立即更新 DOM，而是在下一个 tick 中执行更新，这样可以提高性能，避免不必要的重渲染。
这时候，如果 v-for 所遍历的数据同一时间发生了多个变化，就可能会出现渲染结果混乱的问题。
为了解决这个问题

01. 使用`vue.nextTick`

```js
this.$nextTick(() => {
    // DOM 更新
});
```

02. 给 v-for 迭代的元素添加 key

```vue
<span v-for="(item, id) in items" :key="id"></span>
```

## 2023-3-2

> [软技能] 请说说你对Major GC和Minor GC的理解

`Major GC` 是指发生在老生代的垃圾回收， `Minor GC` 是指发生在新生代的垃圾回收。前者的回收频率较低，后者的回收频率较高。前者的回收时间较长，后者的回收时间较短。前者需要暂停整个应用程序，以便正确的标记和回收堆中的对象，后者不需要暂停整个应用程序，只回收新生代中的对象。

在 `Minor GC` 中，新生代的内存空间被划分为两个相等的区域，一个是 `From` 区，一个是 `To` 区。当 `Minor GC` 开始时，存活的对象会被复制到 `To` 区，然后 `From` 区和 `To` 区的角色进行交换，最后清空 `From` 区。这样，就完成了一次 `Minor GC` 。而在 `Major GC` 中，会对整个老生代进行垃圾回收，这个过程会暂停整个应用程序。

## 2023-3-3

> [css] 说说你对content-visibility的理解

`content-visibility` 是一个CSS属性，用于控制元素的内容是否可见，以及是否可见时是否可交互。它可以用于提高页面的性能，因为它可以让浏览器在不需要时跳过渲染元素的内容，从而减少页面的渲染时间。

## 2023-3-4

> [软技能] 什么时候会触发Minor GC？

当新生代的内存空间不足以存放新的对象时，就会触发 `Minor GC` 。当然，这里的新生代的内存空间不足，是指 `From` 区和 `To` 区的内存空间不足，而不是整个新生代的内存空间不足。

## 2023-3-5

> [软技能] 如何优化动画的性能？

01. 使用CSS3动画：CSS3动画使用浏览器硬件加速，比使用JavaScript动画更加高效。在设计动画时，应该尽量使用CSS3动画。
02. 减少样式计算：在设计动画时，应该避免使用会导致样式计算的属性，比如：box-shadow、border-radius等。
03. 减少重绘和重排：重绘和重排是动画性能的主要瓶颈，应该尽量避免。可以使用requestAnimationFrame函数优化动画的绘制和布局。
  

```
  // html
  <div id="box"></div>
  // css
  #box {
      width: 100px;
      height: 100px;
      background-color: red;
  }
  // js
  let box = document.getElementById('box');
  let x = 0;
  function animate() {
      x++;
      box.style.transform = `translateX(${x}px)`;
      requestAnimationFrame(animate);
  }

  ```

04. 使用硬件加速：在动画过程中，应该使用硬件加速来提高动画的流畅度。可以使用transform属性来启用硬件加速。
05. 使用合适的图片格式：在动画中使用的图片应该使用合适的格式，如：JPEG、PNG或GIF。使用合适的格式可以减小图片的大小，从而提高动画性能。
06. 压缩和缓存：在动画中使用的脚本、样式和图片应该进行压缩和缓存，以减小文件大小，提高动画性能。
07. 控制动画帧数：降低动画的帧数可以减少渲染负担，从而提高动画性能。应该根据动画的复杂度和运行环境适当调整帧数。
08. 减少动画元素数量：减少动画中的元素数量，可以减轻渲染的负担，从而提高动画性能。
09. 使用GPU加速：使用CSS3 3D变换、canvas和WebGL等技术可以启用GPU加速，提高动画的性能。
10. 使用性能分析工具：使用性能分析工具可以帮助你找出动画性能瓶颈，从而有针对性地进行优化。

## 2023-3-6

> [js] 请描述下空值合并运算符（??）

空值合并运算符（ `??` ）是一个逻辑运算符，用于返回第一个非空值。如果所有的操作数都是空值，则返回最后一个操作数。

下面是一个例子 `??` 使用例子：

```js
const foo = null ?? 'default string';
console.log(foo);
// Expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// Expected output: 0

const cak = '' ?? 'default string';
console.log(cak);
// Expected output: ""

const ddd = undefined ?? 'default string';
console.log(ddd);
// Expected output: "default string"
```

## 2023-3-7

> [软技能]  ES2021有哪些新的特性？

01. String.prototype.replaceAll()：替换字符串中所有匹配的子字符串，而不仅仅是第一个。
02. WeakRef 和 FinalizationRegistry：提供了更好的内存管理，可以更轻松地跟踪对象的使用情况。
03. Logical Assignment Operators：新增了逻辑赋值运算符（&&=，||=，??=）。
04. 数字分隔符：在数字中添加下划线作为分隔符，可以增强数字的可读性。
05. Promise.any()：允许你传递一个 Promise 数组，返回最先 resolve 或 reject 的 Promise 的结果。
06. 元素或属性的私有命名：新增了 # 符号，可以用于命名类或对象的私有属性。
07. Error Cause（错误原因）：新增了一个 name 和 cause 属性，可以用于识别错误的来源和原因。
08. 数组的 .at() 方法：新增了 .at() 方法，用于获取数组中指定位置的元素。
09. Private Methods 和 Private Fields：这是一项新的语言特性，允许类和对象拥有私有的方法和属性，而不必通过命名约定等方式来实现私有性。
10. AggregateError：这是一个新的 Error 类型，用于将多个错误集合在一起

## 2023-3-8

> [ECMAScript] 请描述下逻辑赋值操作符（&&=，||=，??=）

逻辑赋值操作符（ `&&=` ， `||=` ， `??=` ）是一种新的赋值操作符，用于将逻辑运算的结果赋值给变量。它们是 `&&` ， `||` 和 `??` 运算符的结合，可以用于简化赋值操作。

```js
let a = true;
let b = false;

a && = b; // 等同于 a = a && b;

console.log(a); // 输出 false

let a = true;
let b = false;

a || = b; // 等同于 a = a || b;

console.log(a); // 输出 true

let a = null;
let b = 'Hello World';

a ?? = b; // 等同于 a = (a !== null && a !== undefined) ? a : b;

console.log(a); // 输出 "Hello World"
```

## 2023-3-9

> [js] 请描述下Promise.any()方法

`Promise.any()` 方法接收一个 Promise 数组，返回一个新的 Promise 对象。只要数组中的一个 Promise 对象成功，新的 Promise 对象就会成功；如果数组中所有的 Promise 对象都失败，新的 Promise 对象就会失败。

```js
const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2];
Promise.any(promises).then((value) => console.log(value));
// 3
const promise4 = Promise.reject('foo');
const promise5 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises2 = [promise4, promise5];
Promise.any(promises2).catch((error) => console.log(error));
// AggregateError: All promises were rejected
```

## 2023-3-10

> [js]  请描述下Promise.allSettled()方法

`Promise.allSettled()` 方法接收一个 Promise 数组，返回一个新的 Promise 对象。只有当数组中的所有 Promise 对象都返回结果，无论是成功还是失败，新的 Promise 对象才会返回结果。

```js
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2, promise3];
Promise.allSettled(promises).then((results) => console.log(results));
// [
//   { status: 'fulfilled', value: 3 },
//   { status: 'fulfilled', value: 42 },
//   { status: 'rejected', reason: 'foo' }
// ]
```

## 2023-3-11

> [js] 请描述下Promise.all()方法

`Promise.all()` 方法接收一个 Promise 数组，返回一个新的 Promise 对象。只有当数组中的所有 Promise 对象都返回结果，新的 Promise 对象才会返回结果。

```js
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2, promise3];
Promise.all(promises).then((values) => console.log(values));
// [3, 42, "foo"]
```

## 2023-3-12

> [js] DOM获取元素尺寸的属性有哪些？

在JavaScript中，获取DOM元素尺寸的属性有以下几种：

1. offsetWidth/offsetHeight：获取元素的宽度/高度，包括元素的边框（border）、内边距（padding）和滚动条（如果有）的宽度/高度。

 

## 2023-3-13

> [js] DOM获取元素尺寸的属性有哪些？
 
1. offsetWidth/offsetHeight：获取元素的宽度/高度，包括元素的边框（border）、内边距（padding）和滚动条（如果有）的宽度/高度。
2. clientWidth/clientHeight：获取元素的可视区域的宽度/高度，不包括边框（border）和滚动条（如果有），但包括内边距（padding）。
3. scrollWidth/scrollHeight：获取元素的内容的实际宽度/高度，包括未显示的部分，但不包括边框（border）和滚动条（如果有）。
4. getComputedStyle(element).width/getComputedStyle(element).height：获取元素的计算样式中的宽度/高度，包括所有的边框、内边距、内容宽度，但不包括滚动条（如果有）。

需要注意的是，以上属性获取的值可能会因为浏览器的不同而有所不同。例如，`clientWidth` 和 `clientHeight` 属性在IE8及以下版本中，不包括内边距（padding）。

## 2023-3-14

+ [js] 请使用createNodeIterator写一个方法遍历页面中的所有元素

```js
function traverse(node) {
  const iterator = document.createNodeIterator(
    node,
    NodeFilter.SHOW_ELEMENT,
    null,
  );
  let currentNode = iterator.nextNode();
  while (currentNode) {
    console.log(currentNode);
    currentNode = iterator.nextNode();
  }
}
```

## 2023-3-15

>  [软技能] 为什么获取clientWidth属性，浏览器会重排重绘？

获取元素的clientWidth属性时，浏览器需要计算元素的布局信息，以确保返回的宽度值是准确的。这个过程包括了重排和重绘的操作，从而会产生一定的性能开销。

因为获取clientWidth属性会访问元素的布局信息，这个布局信息可能因为某些原因而不准确，比如元素的位置或者大小发生了改变。为了确保返回的值是正确的，浏览器需要对元素进行重新布局，这就是重排。重渲染是重排后的结果，即浏览器把元素的新位置和大小应用到屏幕上，重新绘制这个元素。

因此，经常获取clientWidth属性会导致浏览器频繁重排重绘，降低页面性能。为了避免这种情况，可以尽量避免频繁获取clientWidth属性。

## 2023-3-16

>  [js] 使用js写一个方法，使得结果值映射到[0-1]之间(数据归一化)

```js
function normalize(arr) {
  const max = Math.max(...arr);
  const min = Math.min(...arr);
  return arr.map((item) => (item - min) / (max - min));
}
```

## 2023-3-17

>  [软技能] 请问git log和git reflog有什么区别？

`git log` 命令用于查看提交历史记录，`git reflog` 命令用于查看所有分支的提交历史记录。

```bash
$ git log
commit 3b0e2d9e8b0b4c9b5b6b4c9b5b6b4c9b5b6b4c9b

$ git reflog
~/r/moe-c-count # ❯❯❯ git reflog
6b8ad5a (HEAD -> main, origin/main, origin/HEAD) HEAD@{0}: commit: chore: mailer send feature success
b6460e0 HEAD@{1}: clone: from github.com:bertcai/moe-c-count.git
```

## 2023-3-18

 > [软技能] 请解释一下git的游离分支是什么？
 
游离分支是指在本地创建的分支，但是没有与远程分支关联的分支。游离分支可以通过`git branch -d`命令删除，但是如果游离分支中有未合并的提交，那么这些提交将会丢失。